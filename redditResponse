# OnClick Events
{
	- TL;DR: There is only one @onclick event now.
	
	When I first wrote the editor I put an @onclick on every character that was displayed.
	
	This was so I knew what character the user clicked.
	
	The issue with this approach is that it requires every character to be wrapped in a
	<span> HTML element.
	
	Perhaps it used to look something like this: 
		<span @onclick="@NotifyRowIndexAndColumnIndexClicked">@Character</span>
	
	Now I have one @onclick that is on the scrollable viewport that is the TextEditor component
	itself.
	
	The new way looks something like this:
		<div class="pte_plain-text-editor-display pte_unselectable"
		     id="@GetTextEditorElementId"
		     @onkeydown="HandleOnKeyDown"
		     @onkeydown:preventDefault="true"
		     @oncustomclick="HandleOnCustomClick">
		     
		     @* File Contents *@
	     
        </div>
	 
	Lastly for this section would be the HandleOnCustomClick() method:         
		private async Task HandleOnCustomClick(CustomOnClick customOnClick)
	    {
	       	// Going to leave out fine grained details for brevity
	       	
	       	// Get the @onclick position in respect to the position of the TextEditor viewport itself
	       	// NOT the overall viewport.
	       	_mostRecentRelativeCoordinates = await JsRuntime
			.InvokeAsync<RelativeCoordinates>("blazorStudio.getRelativePosition",
			GetTextEditorElementId,
			customOnClick.ClientX,
			customOnClick.ClientY);
				
			var columnIndexDouble = RelativeX / CharacterWidth;
			var columnIndexRounded = Math.Round(columnIndexDouble);
				
			var rowIndex = (int)(RelativeY / RowHeight);
			
			// Tab keys for example can have a width > 1 character and 
			// must offset the cursor position accordingly.
			var tabsOnSameRowBeforeCursor = textEditor
			    .GetTabsCountOnSameRowBeforeCursor(rowIndex, columnIndex);
		        
		        // Going to leave out fine grained details for brevity
		}
}

# Cursor Movement
{
	- TL;DR: A cursor is not part of the TextEditor. It is instead maintained by an outside
		 state that leverages the Cursor as means to keep track of their position.
		 However, the TextEditor knows nothing of the Cursor other than at method
		 invocations like "My cursor is here, what character am I at".

	Previously I had the Cursor as part of the TextEditor itself. 
	
	I want the TextEditor to support ( Undo / Redo ) operations with relative ease.
	So I had a lot of the TextEditor as immutable state.
	The result of this was that with the Cursor was tied to the TextEditor.
	Therefore movement operations of even just 1 character resulted in a complete copy of the TextEditor being constructed everytime.
	
	As a slight aside I believe ( multi-cursor editing / vertical editing ) can be done with
	relative ease with the separation of concerns in regards to the Cursor and TextEditor.
	
	If a Blazor component chose to do so they could just track many cursors then foreach() loop
	over the cursor for the @onkeydown event.
}


# Tokenization
{
	- TL;DR: I used to iterate through the TextFile upon initial load and constructing 'tokens'.
		 So, "Hello World!" would result previously in:
		 	TextEditor
		 	{
			 	{ "Hello", DefaultTextToken },
			 	{ " ", WhitespaceTextToken },
			 	{ "World", DefaultTextToken },
			 	{ "!", PunctuationTextToken }
		 	}
	 	Instead of tokenizing file content I instead have the class Type:
		 	public record TextCharacter(char Value)
			{
			    public byte DecorationByte { get; set; }
			}
		So, the representation of the TextFile in memory is just every character being wrapped
		in a class that adds 1 byte of data to every character.
		
		The DecorationByte then maps to a CSS class when rendering to the UI.
		
		When rendering to the UserInterface I then say:
		
		var spanBuilder = new StringBuilder();
		@foreach (var textCharacter in textSpan.Item.TextCharacters)
		{
			if (textCharacter.DecorationByte == previousDecorationByte)
			{
				spanBuilder.Append(textCharacter.Value);
			}
			else
			{
				<span class="@DecorationKindHelper.ToDecorationKindCssStyleString(currentDecorationByte)">
                    @((MarkupString)spanTextBuilder.ToString())
                </span>

                spanTextBuilder.Clear();

                currentDecorationByte = textCharacter.DecorationByte;
                spanTextBuilder.Append(textCharacter.Value);
			}
		}
		
		Therefore contiguous characters of the same css styling get rendered under a single <span> element.
		
		As well, the record TextCharacter as an immutable char Value. However, it has a MUTABLE
		DecorationByte. This allows for fast UI updates for syntax highlighting.
}


# Less HTML Elements Rendered
{
	- TL;DR: The sections "# OnClick Events" and "# Tokenization" resulted in DRASTIC reduction in HTML elements being rendered.
}


# ( Undo / Redo ) logic
{
	TL;DR: I used to make copies of the TextEditor constantly as the TextEditor was completely immutable.
		   Instead I have the TextEditor manage mutable state privately, and expose immutable state publicly.
		   Every edit action the user makes to the TextEditor has an enum associated with it.
		   public enum TextEditKind
	       {
	           Other,
			   Insertion,
			   Deletion
		   }
		   
		   If the user makes consecutive edits to the TextEditor of the previous TextEditKind then the
		   edits are merged into one large edit.
		   
		   Anytime the user makes an edit to the TextEditor NOT of the previous TextEditKind then the
		   string content of the TextEditor is captured prior to that change. Therefore the user
		   can undo that 'edit block' perfectly.	   
}

# Virtualization
{
	TL;DR: I used to use the built in <Virtualize> component that Microsoft provides.
		   The <Virtualize> component is very useful however I felt I needed to write my own
		   so I had more control over the fine grained details.
		   
		   For example, I used to in the <Virtualize> component render something like:
		   	   <Virtualize>
		   	       @* virtualization-boundary is what I'm denoting for Microsoft's end. *@
		   	   	   <div class="virtualization-boundary-top"></div>
				   <div style="display: flex;" class="row-wrapper">
					   <div class="row-line-number">5</div>
	   			       <div class="row-content">abcdefg</div>
	   			       @* Somewhere in here I rendered the Cursor that's an important detail *@
				   </div>
   		   	   	   <div class="virtualization-boundary-bottom"></div>
			   </Virtualize>
			   
		   Now it looks something like:
		   <VirtualizeCoordinateSystem>
               <div class="bstudio_text-editor-display-gutter" 
                    style="position: absolute; top: rowIndex * rowHeight;">
                            @textSpan.Index
                </div> 
                        
                <div style="white-space: nowrap; position: absolute; top: rowIndex * rowHeight; left: lineNumberWidth;">
					var spanBuilder = new StringBuilder();
					@foreach (var textCharacter in textSpan.Item.TextCharacters)
					{
						@* see # Tokenization *@
					}
                </div>
            </VirtualizeCoordinateSystem>

            <TextEditorCursorDisplay @ref="_textEditorCursorDisplay"
                                     TextCursor="_cursor"
                                     TextEditorBase="TextEditorStatesSelection.Value"
                                     RowHeightInPixels="_textEditorFontSize?.RowHeight ?? 0"
                                     CharacterWidthInPixels="_textEditorFontSize?.CharacterWidth ?? 0" />
                                     
         	@* 
         		So, note how I am Virtualizing now two separate elements and using absolute positioning. 
         		
         		Aswell, the TextEditorCursorDisplay is outside the Virtualization.
     		*@
}
